// Implementation of a cache for arbitrary k8s custom resource in openebs.io
// api with v1alpha1 version.

import * as _ from 'lodash';
import events = require('events');
import {
  CustomObjectsApi,
  HttpError,
  KubeConfig,
  KubernetesObject,
  KubernetesListObject,
  ListWatch,
  V1ListMeta,
  Watch,
} from '@kubernetes/client-node';

const log = require('./logger').Logger('watcher');

// If listWatch errors out then we restart it after this many msecs.
const RESTART_DELAY: number = 3000;
// We wait this many msecs for an event confirming operation done previously.
const EVENT_TIMEOUT: number = 5000;
const GROUP: string = 'openebs.io';
const VERSION: string = 'v1alpha1';

// Errors generated by api requests are hopelessly useless. We need to add
// a text from http body to them.
function bodyError(prefix: string, error: any): any {
  if (error instanceof HttpError) {
    error.message = prefix + ': ' + error.body.message;
  } else {
    error.message = prefix + ': ' + error.message;
  }
  return error;
}

// Commonly used metadata attributes.
export class CustomResourceMeta extends V1ListMeta {
  name?: string;
  namespace?: string;
  generation?: number;
  finalizers?: string[];
}

// Properties of custom resources (all optional so that we can do easy
// conversion from "object" type)
export class CustomResource implements KubernetesObject {
  apiVersion?: string;
  kind?: string;
  metadata?: CustomResourceMeta;
  spec?: object;
  status?: any;
}

class TimeoutError extends Error {
  constructor() {
    super();
  }
}

// Utility class for wrapping asynchronous operations that once done, need to be
// confirmed by something from outside (i.e. watcher event). If confirmation does
// not arrive on time, then end the operation regardless and let user know.
class ConfirmOp {
  private id: string;
  private timer: NodeJS.Timeout | null;
  private timeout: number;
  private since: number;
  private confirmed: boolean;
  private done: boolean;
  private resolve?: () => void;
  private reject?: (err: any) => void;

  constructor(id: string, timeout: number) {
    this.id = id;
    this.timeout = timeout;
    this.since = 0;
    this.timer = null;
    this.confirmed = false;
    this.done = false;
  }

  run(action: () => Promise<void>): Promise<void> {
    this.since = (new Date()).getTime();
    if (this.timeout <= 0) {
      this.confirmed = true;
    }
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      action()
      .then(() => {
        this.done = true;
        if (!this.confirmed) {
          this.timer = setTimeout(() => {
            const delta = (new Date()).getTime() - this.since;
            log.warn(`Timed out waiting for watcher event on "${this.id}" (${delta}ms)`);
            this.timer = null;
            reject(new TimeoutError());
          }, this.timeout);
        } else {
          this._complete();
        }
      })
      .catch((err) => {
        this.done = true;
        this._complete(err);
      });
    });
  }

  // Beware that confirm can come before the operation done callback!
  confirm() {
    this.confirmed = true;
    if (this.timeout > 0) {
      this._complete();
    }
  }

  _complete(err?: any) {
    if (!err && (!this.confirmed || !this.done)) return;

    const delta = (new Date()).getTime() - this.since;
    log.trace(`The operation on "${this.id}" took ${delta}ms`);
    if (this.timer) {
      clearTimeout(this.timer);
    }
    if (err) {
      this.reject!(err);
    } else {
      this.resolve!();
    }
  }
}

// Resource cache keeps track of a k8s custom resource and exposes methods
// for modifying the cache content.
//
// It is a classic operator loop design as seen in i.e. operator-sdk (golang)
// to watch a k8s resource. We utilize k8s client library to take care of low
// level details.
//
// It is a general implementation of watcher which can be used for any resource
// operator. The operator should subscribe to "new", "mod" and "del" events that
// are triggered when a resource is added, modified or deleted.
export class CustomResourceCache<T> extends events.EventEmitter {
  name: string;
  plural: string;
  namespace: string;
  waiting: Record<string, ConfirmOp>;
  k8sApi: CustomObjectsApi;
  listWatch: ListWatch<CustomResource>;
  creator: new (obj: CustomResource) => T;
  eventHandlers: Record<string, (obj: CustomResource) => void>;
  connected: boolean;
  restartDelay: number;
  idleTimeout: number;
  eventTimeout: number;
  timer: any;

  // Create the cache for given namespace and resource name.
  //
  // @param namespace   Namespace of custom resource.
  // @param name        Name of the resource.
  // @param kubeConfig  Kube config object.
  // @param creator     Constructor of the object from custom resource object.
  // @param opts        Cache/watcher options.
  constructor(
    namespace: string,
    name: string,
    kubeConfig: KubeConfig,
    creator: new (obj: CustomResource) => T,
    opts?: {
      restartDelay?: number,
      eventTimeout?: number,
      idleTimeout?: number
    }
  ) {
    super();
    this.k8sApi = kubeConfig.makeApiClient(CustomObjectsApi);
    this.name = name;
    this.plural = name + 's';
    this.namespace = namespace;
    this.creator = creator;
    this.waiting = {};
    this.connected = false;
    this.restartDelay = opts?.restartDelay || RESTART_DELAY;
    this.eventTimeout = opts?.eventTimeout || EVENT_TIMEOUT;
    this.idleTimeout = opts?.idleTimeout || 0;
    this.eventHandlers = {
      add: this._onEvent.bind(this, 'new'),
      update: this._onEvent.bind(this, 'mod'),
      delete: this._onEvent.bind(this, 'del'),
    };

    const watch = new Watch(kubeConfig);
    this.listWatch = new ListWatch<CustomResource>(
      `/apis/${GROUP}/${VERSION}/namespaces/${this.namespace}/${this.plural}`,
      watch,
      async () => {
        var resp = await this.k8sApi.listNamespacedCustomObject(
          GROUP,
          VERSION,
          this.namespace,
          this.plural);
        return {
          response: resp.response,
          body: resp.body as KubernetesListObject<CustomResource>,
        };
      },
      false
    );
  }

  // Clear idle/restart timer.
  _clearTimer() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = undefined;
    }
  }
  // Install a timer that restarts watcher if idle for more than x seconds.
  // On Azure AKS we have observed watcher connections that don't get any
  // events after some time when idle.
  _setIdleTimeout() {
    if (this.idleTimeout > 0) {
      this._clearTimer();
      this.timer = setTimeout(() => {
        this.stop();
        this.start();
      }, this.idleTimeout);
    }
  }

  // Called upon a watcher event. It unblocks create or update operation if any
  // is waiting for the event and propagates the event further.
  _onEvent(event: string, cr: CustomResource) {
    let name = cr.metadata?.name;
    if (name === undefined) {
      log.error(`Ignoring event ${event} with object without a name`);
      return;
    }
    log.trace(`Received watcher event ${event} for ${this.name} "${name}": ${JSON.stringify(cr)}`);
    this._setIdleTimeout();
    let confirmOp = this.waiting[name];
    if (confirmOp) {
      confirmOp.confirm();
    }
    this._doWithObject(cr, (obj) => this.emit(event, obj));
  }

  // Convert custom resource object to desired object swallowing exceptions
  // and call callback with the new object.
  _doWithObject(obj: CustomResource | undefined, cb: (obj: T) => void): void {
    if (obj === undefined) return;

    try {
      var newObj = new this.creator(obj);
    } catch (e) {
      log.error(`Ignoring invalid ${this.name} custom resource: ${e}`);
      return;
    }
    cb(newObj);
  }

  // This method does not return until the cache is successfully populated.
  // That means that the promise eventually always fulfills (resolves).
  start(): Promise<void> {
    this.listWatch.on('error', this._onError.bind(this));
    for (let evName in this.eventHandlers) {
      this.listWatch.on(evName, this.eventHandlers[evName]);
    }
    return this.listWatch.start()
      .then(() => {
        this.connected = true;
        log.debug(`${this.name} watcher with ${this.listWatch.list().length} objects was started`);
        log.trace(`Initial content of the "${this.name}" cache: ` +
          this.listWatch.list().map((i: CustomResource) => i.metadata?.name));
        this._setIdleTimeout();
      })
      .catch((err) => {
        log.error(`Failed to start ${this.name} watcher: ${err}`)
        this.stop();
        log.info(`Restart ${this.name} watcher after ${this.restartDelay}ms...`);
        return new Promise((resolve, reject) => {
          this.timer = setTimeout(() => {
            this.start().then(resolve, reject);
          }, this.restartDelay);
        });
      });
  }

  // Called when the connection breaks.
  _onError(err: any) {
    log.error(`Watcher error: ${err}`);
    this.stop();
    log.info(`Restarting ${this.name} watcher after ${this.restartDelay}ms...`);
    this.timer = setTimeout(() => this.start(), this.restartDelay);
  }

  // Deregister all internal event handlers on the watcher.
  stop() {
    this._clearTimer();
    this.connected = false;
    log.debug(`Deregistering "${this.name}" cache event handlers`);
    this.listWatch.off('error', this._onError);
    for (let evName in this.eventHandlers) {
      this.listWatch.off(evName, this.eventHandlers[evName]);
    }
    this.listWatch.stop();
  }

  isConnected(): boolean {
    // should we propagate event to consumers about the reset?
    return this.connected;
  }

  // Get all objects from the cache.
  list(): T[] {
    let list: T[] = [];
    this.listWatch.list().forEach((item) => {
      this._doWithObject(item, (obj) => list.push(obj));
    });
    return list;
  }

  // Get object with given name (ID).
  get(name: string): T | undefined {
    var result;
    this._doWithObject(this.listWatch.get(name), (obj) => result = obj);
    return result;
  }

  // Execute the action and do not return until we receive an event from watcher.
  // Otherwise the object in the cache might be stale when we do the next
  // modification to it. Set timeout for the case when we never receive the
  // event and restart the watcher to get fresh content in that case.
  async _waitForEvent(name: string, action: () => Promise<void>) {
    this.waiting[name] = new ConfirmOp(name, this.eventTimeout);
    try {
      await this.waiting[name].run(action);
    } catch (err) {
      delete this.waiting[name];
      if (err instanceof TimeoutError) {
        // restart the cache
        this.stop();
        await this.start();
      } else {
        throw err;
      }
    }
  }

  // Create the resource and wait for it to be created.
  async create(obj: CustomResource) {
    let name: string = obj.metadata?.name || '';
    if (!name) {
      throw Error("Object does not have a name");
    }
    log.trace(`Creating new "${this.name}" resource: ${JSON.stringify(obj)}`);
    await this._waitForEvent(
      name,
      async () => {
        try {
          await this.k8sApi.createNamespacedCustomObject(
            GROUP,
            VERSION,
            this.namespace,
            this.plural,
            obj
          );
        } catch (err) {
          throw bodyError(`Delete of ${this.name} "${name}" failed`, err);
        }
      }
    );
  }

  // Update the resource. The merge callback takes the original version from
  // the cache, modifies it and returns the new version of object. The reason
  // for this is that sometimes we get stale errors and we must repeat
  // the operation with an updated version of the original object.
  async update(name: string, merge: (orig: T) => CustomResource | undefined) {
    await this._update(name, () => {
      let orig = this.get(name);
      if (orig === undefined) {
        log.warn(`Tried to update ${this.name} "${name}" that does not exist`);
        return;
      }
      return merge(orig);
    });
  }

  // Same as above but works with custom resource type rather than user
  // defined object.
  async _updateCustomResource(name: string, merge: (orig: CustomResource) => CustomResource | undefined) {
    await this._update(name, () => {
      let orig = this.listWatch.get(name);
      if (orig === undefined) {
        log.warn(`Tried to update ${this.name} "${name}" that does not exist`);
        return;
      }
      return merge(orig);
    });
  }

  // Update the resource and wait for mod event. If update fails due to an error
  // we restart the watcher and retry the operation. If event does not come,
  // we restart the watcher.
  async _update(
    name: string,
    getAndMerge: () => CustomResource | undefined,
  ) {
    for (let retries = 1; retries >= 0; retries -= 1) {
      let obj = getAndMerge();
      if (obj === undefined) {
        // likely means that the props are the same - nothing to do
        return;
      }
      log.trace(`Updating ${this.name} "${name}": ${JSON.stringify(obj)}`);
      try {
        await this._waitForEvent(
          name,
          async () => {
            await this.k8sApi.replaceNamespacedCustomObject(
              GROUP,
              VERSION,
              this.namespace,
              this.plural,
              name,
              obj!
            );
          }
        );
        break;
      } catch (err) {
        err = bodyError(`Update of ${this.name} "${name}" failed`, err);
        if (retries == 0) {
          throw err;
        }
        log.warn(`${err} (retrying ...)`);
        this.stop();
        await this.start();
      }
    }
  }

  // Update status of the resource. Unlike in case create/update we don't have
  // to wait for confirming event because generation number is not incremented
  // upon status change.
  async updateStatus(name: string, merge: (orig: T) => CustomResource | undefined) {
    for (let retries = 1; retries >= 0; retries -= 1) {
      let orig = this.get(name);
      if (orig === undefined) {
        log.warn(`Tried to update status of ${this.name} "${name}" but it is gone`);
        return;
      }
      let obj = merge(orig);
      if (obj === undefined) {
        // likely means that the props are the same - nothing to do
        return;
      }
      log.trace(`Updating status of ${this.name} "${name}": ${JSON.stringify(obj.status)}`);
      try {
        await this._waitForEvent(
          name,
          async () => {
            await this.k8sApi.replaceNamespacedCustomObjectStatus(
              GROUP,
              VERSION,
              this.namespace,
              this.plural,
              name,
              obj!
            );
          }
        );
        break;
      } catch (err) {
        err = bodyError(`Status update of ${this.name} "${name}" failed`, err);
        if (retries == 0) {
          throw err;
        }
        log.warn(`${err} (retrying ...)`);
        this.stop();
        await this.start();
      }
    }
  }

  // Delete the resource.
  async delete(name: string) {
    let orig = this.get(name);
    if (orig === undefined) {
      log.warn(`Tried to delete ${this.name} "${name}" that does not exist`);
      return new Promise((resolve) => resolve(undefined));
    }
    log.trace(`Deleting ${this.name} "${name}"`);
    await this._waitForEvent(
      name,
      async () => {
        try {
          await this.k8sApi.deleteNamespacedCustomObject(
            GROUP,
            VERSION,
            this.namespace,
            this.plural,
            name
          );
        } catch (err) {
          throw bodyError(`Delete of ${this.name} "${name}" failed`, err);
        }
      }
    );
  }

  // Add finalizer to given resource if not already there.
  async addFinalizer(name: string, finalizer: string) {
    await this._updateCustomResource(name, (orig) => {
      let finalizers = orig.metadata?.finalizers;
      let newFinalizers = finalizers || [];
      if (newFinalizers.indexOf(finalizer) >= 0) {
        // it's already there
        return;
      }
      newFinalizers = [finalizer].concat(newFinalizers);
      let obj = _.cloneDeep(orig);
      if (obj.metadata === undefined) {
        throw new Error(`Resource ${this.name} "${name}" without metadata`)
      }
      obj.metadata.finalizers = newFinalizers;
      return obj;
    });
  }

  // Remove finalizer from the resource in case it's there.
  async removeFinalizer(name: string, finalizer: string) {
    await this._updateCustomResource(name, (orig) => {
      let finalizers = orig.metadata?.finalizers;
      let newFinalizers = finalizers || [];
      let idx = newFinalizers.indexOf(finalizer);
      if (idx < 0) {
        // it's not there
        return;
      }
      newFinalizers.splice(idx, 1);
      let obj = _.cloneDeep(orig);
      if (obj.metadata === undefined) {
        throw new Error(`Resource ${this.name} "${name}" without metadata`)
      }
      obj.metadata.finalizers = newFinalizers;
      return obj;
    });
  }
}
